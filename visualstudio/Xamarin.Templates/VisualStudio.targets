<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- Until we can move to SDK style and XVSSDK -->
	<Import Project="Xamarin.VSSDK.Xaml.targets" />

	<PropertyGroup>
		<DeployExtension Condition=" '$(DeployExtension)' == '' And '$(Configuration)' == 'Debug' ">true</DeployExtension>

	</PropertyGroup>

	<Target Name="GetVsixVersion" DependsOnTargets="GitVersion" Returns="$(VsixVersion)">
		<PropertyGroup>
			<VsixVersion Condition="'$(Configuration)' == 'Debug'">1.0.0</VsixVersion>
			<VsixVersion Condition="'$(VsixVersion)' == ''">$(GitSemVerMajor).$(GitSemVerMinor).$(GitSemVerPatch)</VsixVersion>
		</PropertyGroup>
	</Target>

	<Target Name="AppendVsixVersionToTargetVsixContainer" BeforeTargets="CreateVsixContainer" DependsOnTargets="GetVsixVersion">
		<PropertyGroup>
			<TargetVsixContainer>$([System.IO.Path]::ChangeExtension('$(TargetVsixContainer)', '$(VsixVersion).vsix'))</TargetVsixContainer>
		</PropertyGroup>
	</Target>

  <Target Name="FindVsTemplates"
			DependsOnTargets="FindSmartTemplateCandidates;IncludeSmartTemplateFiles">
    <ItemGroup>
      <_VsTemplate Include="@(SmartTemplateContentWithTargetPath)"
						 Condition=" '%(Extension)' == '.vstemplate' " />
    </ItemGroup>
  </Target>
  
	<!-- Patch VSSDK uninstall VSIX broken logic	
	Before we even import Clarius.VisualStudio targets, which in turn import VSSDK ones, 
	we declare our own re-implementation of the UninstallExtension task that just marks 
	an extension for deletion on the next VS restart. This completely removes the random
	build errors we were getting when a version flagged 0.1 couldn't uninstall a newer 
	(i.e. 5.0) version that was already installed in the experimental hive.
	 -->
	<UsingTask TaskName="UninstallExtension" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskAssembly)" Condition="'$(CodeTaskAssembly)' != ''">
		<ParameterGroup>
			<VsixIdentifier Required="true" />
			<RootSuffix  Required="true" />
			<FailIfNotInstalled  Required="true" />
		</ParameterGroup>
		<Task>
			<Reference Include="Microsoft.CSharp" />
			<Using Namespace="Microsoft.Build.Framework" />
			<Using Namespace="System.Reflection" />
			<Code Type="Fragment" Language="cs">
				<![CDATA[
			Log.LogMessage("Marking extension for deletion on the next Visual Studio start: {0}.", VsixIdentifier);
				
			try {
			    var tasks = AppDomain.CurrentDomain.GetAssemblies ().First (asm => asm.GetName ().Name == "Microsoft.VsSDK.Build.Tasks");
			    var utilities = tasks.GetType ("Microsoft.VsSDK.Build.Tasks.ExtensionManagerUtilities", true);

			    dynamic settingsManager = utilities.InvokeMember ("GetSettingsManagerForDevenv", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { RootSuffix }); ;
			    var extensionManagerService = utilities.InvokeMember ("GetExtensionManagerService", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { settingsManager });
			    var installedExtension = utilities.InvokeMember("GetInstalledExtension", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { extensionManagerService, VsixIdentifier });
			    var header = installedExtension.GetType ().GetProperty ("Header").GetValue (installedExtension);
			    var installedVersion = header.GetType ().GetProperty ("Version").GetValue (header).ToString ();
			    var installedPath = installedExtension.GetType ().GetProperty ("InstallPath").GetValue (installedExtension).ToString ();

			    var scopeType = ((object)settingsManager).GetType ().GetMethod ("GetWritableSettingsStore").GetParameters ()[0].ParameterType;
			    dynamic scope = Enum.Parse (scopeType, "UserSettings");

			    dynamic settingsStore = settingsManager.GetWritableSettingsStore(scope);

			    settingsStore.SetString(@"ExtensionManager\PendingDeletions", VsixIdentifier +  "," + installedVersion, installedPath);
			
			    Log.LogMessage("Successfully marked extension for deletion on the next Visual Studio start: {0}, {1}.", VsixIdentifier, installedVersion);
			} catch (Exception ex) {
			    // If uninstallation of the extension from the experimental instance didn't work, just warn, it's no big deal :)
			    Log.LogWarningFromException(ex);
			}
]]>
			</Code>
		</Task>
	</UsingTask>
</Project>
