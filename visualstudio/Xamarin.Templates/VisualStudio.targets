<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- Until we can move to SDK style and XVSSDK -->
	<Import Project="Xamarin.VSSDK.Xaml.targets" />

	<PropertyGroup>
		<DeployExtension Condition=" '$(DeployExtension)' == '' And '$(Configuration)' == 'Debug' ">true</DeployExtension>
	</PropertyGroup>

	<Target Name="GetVsixVersion" DependsOnTargets="GitVersion" Returns="$(VsixVersion)">
		<PropertyGroup>
			<VsixVersion Condition="'$(Configuration)' == 'Debug'">1.0.0</VsixVersion>
			<VsixVersion Condition="'$(VsixVersion)' == ''">$(GitSemVerMajor).$(GitSemVerMinor).$(GitSemVerPatch)</VsixVersion>
		</PropertyGroup>
	</Target>

	<Target Name="AppendVsixVersionToTargetVsixContainer" BeforeTargets="CreateVsixContainer" DependsOnTargets="GetVsixVersion">
		<PropertyGroup>
			<TargetVsixContainer>$([System.IO.Path]::ChangeExtension('$(TargetVsixContainer)', '$(VsixVersion).vsix'))</TargetVsixContainer>
		</PropertyGroup>
	</Target>

  <Target Name="FindVsTemplates"
			DependsOnTargets="FindSmartTemplateCandidates;IncludeSmartTemplateFiles">
    <ItemGroup>
      <_VsTemplate Include="@(SmartTemplateContentWithTargetPath)"
						 Condition=" '%(Extension)' == '.vstemplate' " />
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <NuGetPath Condition=" '$(NuGetPath)' == '' ">$(MSBuildThisFileDirectory).nuget</NuGetPath>
    <NuGetUrl Condition=" '$(NuGetUrl)' == '' ">https://dist.nuget.org/win-x86-commandline/latest/nuget.exe</NuGetUrl>
    <NuGet Condition=" '$(NuGet)' == '' ">$(NuGetPath)\nuget.exe</NuGet>
    <TEMP Condition=" '$(OS)' != 'Windows_NT' ">$(TMPDIR)</TEMP>
    <BaseUrl Condition=" '$(BaseUrl)' == '' ">https://raw.githubusercontent.com/kzu/NuGet.Restore/master/</BaseUrl>
    <CurlUrl Condition=" '$(CurlUrl)' == '' ">$(BaseUrl)curl.exe</CurlUrl>
    <CurlArgs Condition=" '$(CurlArgs)' == '' ">-k -f -L</CurlArgs>
    <Curl Condition=" '$(OS)' == 'Windows_NT' ">"$(TEMP)\curl.exe" $(CurlArgs)</Curl>
    <Curl Condition=" '$(OS)' != 'Windows_NT' ">curl $(CurlArgs)</Curl>
  </PropertyGroup>
  
  <Target Name="DownloadNuGet" DependsOnTargets="DownloadCurl" Condition=" !Exists('$(NuGet)') ">
    <MakeDir Directories="$(NuGetPath)" Condition=" !Exists('$(NuGetPath)') " />
    <Exec Command="$(Curl) -o &quot;$(NuGet)&quot; &quot;$(NuGetUrl)&quot;" />
  </Target>
  <Target Name="DownloadCurl" Condition=" '$(OS)' == 'Windows_NT' And !Exists('$(TEMP)\curl.exe') ">
    <PropertyGroup>
      <PowerShell Condition=" '$(PowerShell)' == '' ">%WINDIR%\System32\WindowsPowerShell\v1.0\powershell.exe</PowerShell>
    </PropertyGroup>
    <Exec Command="&quot;$(PowerShell)&quot; -NoProfile -Command &quot;&amp; { (New-Object System.Net.WebClient).DownloadFile('$(CurlUrl)', '$(TEMP)\curl.exe') }&quot;" />
  </Target>

  <Target Name="Package" DependsOnTargets="DownloadNuget;GetVsixVersion" BeforeTargets="CoreCompile">
    <ItemGroup>
      <NuSpec Include="$(MSBuildThisFileDirectory)..\..\multiplatform\xamarin-templates-multiplatform.nuspec" />
    </ItemGroup>
    <PropertyGroup>
      <Out>$(MSBuildThisFileDirectory)Templates</Out>
    </PropertyGroup>
    
    <MakeDir Directories="$(Out)" Condition="!Exists('$(Out)')" />

    <Exec Command='"$(NuGet)" Pack "%(NuSpec.Filename)%(NuSpec.Extension)" -NoPackageAnalysis -Version $(VsixVersion) -Properties Id=%(NuSpec.Filename);Configuration=$(Configuration);Version=$(VsixVersion) -OutputDirectory $(Out)'
			  WorkingDirectory='%(NuSpec.RootDir)%(NuSpec.Directory)'/>

    <ItemGroup>
      <Content Include="Templates\Xamarin.Templates.Multiplatform.$(VsixVersion).nupkg">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <IncludeInVSIX>true</IncludeInVSIX>
      </Content>
    </ItemGroup>

    <Message Text="Added Content $(Out)\Xamarin.Templates.Multiplatform.$(VsixVersion).nupkg" Importance="high" />
</Target>


  <!-- Patch VSSDK uninstall VSIX broken logic	
	Before we even import Clarius.VisualStudio targets, which in turn import VSSDK ones, 
	we declare our own re-implementation of the UninstallExtension task that just marks 
	an extension for deletion on the next VS restart. This completely removes the random
	build errors we were getting when a version flagged 0.1 couldn't uninstall a newer 
	(i.e. 5.0) version that was already installed in the experimental hive.
	 -->
	<UsingTask TaskName="UninstallExtension" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskAssembly)" Condition="'$(CodeTaskAssembly)' != ''">
		<ParameterGroup>
			<VsixIdentifier Required="true" />
			<RootSuffix  Required="true" />
			<FailIfNotInstalled  Required="true" />
		</ParameterGroup>
		<Task>
			<Reference Include="Microsoft.CSharp" />
			<Using Namespace="Microsoft.Build.Framework" />
			<Using Namespace="System.Reflection" />
			<Code Type="Fragment" Language="cs">
				<![CDATA[
			Log.LogMessage("Marking extension for deletion on the next Visual Studio start: {0}.", VsixIdentifier);
				
			try {
			    var tasks = AppDomain.CurrentDomain.GetAssemblies ().First (asm => asm.GetName ().Name == "Microsoft.VsSDK.Build.Tasks");
			    var utilities = tasks.GetType ("Microsoft.VsSDK.Build.Tasks.ExtensionManagerUtilities", true);

			    dynamic settingsManager = utilities.InvokeMember ("GetSettingsManagerForDevenv", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { RootSuffix }); ;
			    var extensionManagerService = utilities.InvokeMember ("GetExtensionManagerService", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { settingsManager });
			    var installedExtension = utilities.InvokeMember("GetInstalledExtension", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { extensionManagerService, VsixIdentifier });
			    var header = installedExtension.GetType ().GetProperty ("Header").GetValue (installedExtension);
			    var installedVersion = header.GetType ().GetProperty ("Version").GetValue (header).ToString ();
			    var installedPath = installedExtension.GetType ().GetProperty ("InstallPath").GetValue (installedExtension).ToString ();

			    var scopeType = ((object)settingsManager).GetType ().GetMethod ("GetWritableSettingsStore").GetParameters ()[0].ParameterType;
			    dynamic scope = Enum.Parse (scopeType, "UserSettings");

			    dynamic settingsStore = settingsManager.GetWritableSettingsStore(scope);

			    settingsStore.SetString(@"ExtensionManager\PendingDeletions", VsixIdentifier +  "," + installedVersion, installedPath);
			
			    Log.LogMessage("Successfully marked extension for deletion on the next Visual Studio start: {0}, {1}.", VsixIdentifier, installedVersion);
			} catch (Exception ex) {
			    // If uninstallation of the extension from the experimental instance didn't work, just warn, it's no big deal :)
			    Log.LogWarningFromException(ex);
			}
]]>
			</Code>
		</Task>
	</UsingTask>
</Project>
