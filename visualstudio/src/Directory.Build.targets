<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Until we can move to SDK style and XVSSDK -->
  <Import Project="Xamarin.VSSDK.Xaml.targets" />
  <Import Project="Xamarin.Localization.targets" />

  <PropertyGroup>
    <DeployExtension Condition=" '$(DeployExtension)' == '' And '$(Configuration)' == 'Debug' ">true</DeployExtension>
  </PropertyGroup>

	<PropertyGroup>
		<!-- We use the fourth digit as the base number to add commits on top, which allows us to 
			 to increment between previews before RTW -->
		<_GitBaseVersionExpr>^v?(?&lt;MAJOR&gt;\d+)\.(?&lt;MINOR&gt;\d+)\.(?&lt;PATCH&gt;\d+)(\.(?&lt;COMMITS&gt;\d+))?(?:\-(?&lt;LABEL&gt;[\dA-Za-z\-\.]+))?$|^(?&lt;LABEL&gt;[\dA-Za-z\-\.]+)\-v?(?&lt;MAJOR&gt;\d+)\.(?&lt;MINOR&gt;\d+)\.(?&lt;PATCH&gt;\d+)(\.(?&lt;COMMITS&gt;\d+))?$</_GitBaseVersionExpr>	
	</PropertyGroup>

	<Target Name="AddBaseCommits" BeforeTargets="_GitPopulateVersionInfo" AfterTargets="_GitValidateBaseVersion">
		<PropertyGroup>
			<GitBaseCommits>$([System.Text.RegularExpressions.Regex]::Match($(GitBaseVersion), $(_GitBaseVersionExpr)).Groups['COMMITS'].Value)</GitBaseCommits>
			<GitCommits Condition="'$(GitBaseCommits)' != ''">$([MSBuild]::Add('$(GitBaseCommits)', '$(GitCommits)'))</GitCommits>
		</PropertyGroup>
	</Target>

  <Target Name="UpdateBuildNumber" Condition="'$(CI)' == 'true'" BeforeTargets="Build" DependsOnTargets="GitVersion">
    <Message Importance="high" Text="##vso[build.updatebuildnumber]$(GitBranch)-$(GitCommit) ($(GitSemVerMajor).$(GitSemVerMinor).$(GitSemVerPatch)+$(BUILD_BUILDID))" />
  </Target>

  <Target Name="GetVsixVersion" DependsOnTargets="GitVersion" Returns="$(VsixVersion)">
    <PropertyGroup>
      <VsixVersion Condition="'$(Configuration)' == 'Debug'">42.42.42</VsixVersion>
      <VsixVersion Condition="'$(VsixVersion)' == ''">$(GitSemVerMajor).$(GitSemVerMinor).$(GitSemVerPatch)</VsixVersion>
    </PropertyGroup>
  </Target>

  <Target Name="AppendVsixVersionToTargetVsixContainer" BeforeTargets="CreateVsixContainer" DependsOnTargets="GetVsixVersion">
    <PropertyGroup>
      <TargetVsixContainer>$([System.IO.Path]::ChangeExtension('$(TargetVsixContainer)', '$(VsixVersion).vsix'))</TargetVsixContainer>
    </PropertyGroup>
  </Target>

  <Target Name="FindVsTemplates"
      DependsOnTargets="FindSmartTemplateCandidates;IncludeSmartTemplateFiles">
    <ItemGroup>
      <_VsTemplate Include="@(SmartTemplateContentWithTargetPath)"
             Condition=" '%(Extension)' == '.vstemplate' " />
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <NuGetPath Condition=" '$(NuGetPath)' == '' ">$(MSBuildThisFileDirectory).nuget</NuGetPath>
    <NuGetUrl Condition=" '$(NuGetUrl)' == '' ">https://dist.nuget.org/win-x86-commandline/latest/nuget.exe</NuGetUrl>
    <NuGet Condition=" '$(NuGet)' == '' ">$(NuGetPath)\nuget.exe</NuGet>
    <TEMP Condition=" '$(OS)' != 'Windows_NT' ">$(TMPDIR)</TEMP>
    <BaseUrl Condition=" '$(BaseUrl)' == '' ">https://raw.githubusercontent.com/kzu/NuGet.Restore/master/</BaseUrl>
    <CurlUrl Condition=" '$(CurlUrl)' == '' ">$(BaseUrl)curl.exe</CurlUrl>
    <CurlArgs Condition=" '$(CurlArgs)' == '' ">-k -f -L</CurlArgs>
    <Curl Condition=" '$(OS)' == 'Windows_NT' ">"$(TEMP)\curl.exe" $(CurlArgs)</Curl>
    <Curl Condition=" '$(OS)' != 'Windows_NT' ">curl $(CurlArgs)</Curl>
  </PropertyGroup>

  <Target Name="DownloadNuGet" DependsOnTargets="DownloadCurl" Condition=" !Exists('$(NuGet)') ">
    <MakeDir Directories="$(NuGetPath)" Condition=" !Exists('$(NuGetPath)') " />
    <Exec Command="$(Curl) -o &quot;$(NuGet)&quot; &quot;$(NuGetUrl)&quot;" />
  </Target>
  <Target Name="DownloadCurl" Condition=" '$(OS)' == 'Windows_NT' And !Exists('$(TEMP)\curl.exe') ">
    <PropertyGroup>
      <PowerShell Condition=" '$(PowerShell)' == '' ">%WINDIR%\System32\WindowsPowerShell\v1.0\powershell.exe</PowerShell>
    </PropertyGroup>
    <Exec Command="&quot;$(PowerShell)&quot; -NoProfile -Command &quot;&amp; { (New-Object System.Net.WebClient).DownloadFile('$(CurlUrl)', '$(TEMP)\curl.exe') }&quot;" />
  </Target>

  <Target Name="PackageTemplates" DependsOnTargets="DownloadNuget;GetVsixVersion" AfterTargets="GetVsixSourceItems" >
    <ItemGroup>
      <NuSpec Include="$(MSBuildThisFileDirectory)..\..\multiplatform\xamarin-templates-multiplatform.nuspec" />
      <NuSpec Include="$(MSBuildThisFileDirectory)..\..\android\xamarin-templates-android.nuspec" />
      <NuSpec Include="$(MSBuildThisFileDirectory)..\..\ios\xamarin-templates-ios.nuspec" />
      <NuSpec Include="$(MSBuildThisFileDirectory)..\..\tvos\xamarin-templates-tvos.nuspec" />
      <NuSpec Include="$(MSBuildThisFileDirectory)..\..\watchos\xamarin-templates-watchos.nuspec" />
    </ItemGroup>
    <PropertyGroup>
      <TemplatesFolder>$(MSBuildThisFileDirectory)Templates</TemplatesFolder>
    </PropertyGroup>

    <MakeDir Directories="$(TemplatesFolder)" Condition="!Exists('$(TemplatesFolder)')" />

    <Exec Command='"$(NuGet)" Pack "%(NuSpec.Filename)%(NuSpec.Extension)" -NoPackageAnalysis -Version $(VsixVersion) -Properties Id=%(NuSpec.Filename);Configuration=$(Configuration);Version=$(VsixVersion) -OutputDirectory $(TemplatesFolder)'
        WorkingDirectory='%(NuSpec.RootDir)%(NuSpec.Directory)'/>

    <ItemGroup>
      <VsixSourceItem Include="Templates\Xamarin.Templates.Multiplatform.$(VsixVersion).nupkg">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <IncludeInVSIX>true</IncludeInVSIX>
        <VSIXSubPath>Templates</VSIXSubPath>
      </VsixSourceItem>
      <VsixSourceItem Include="Templates\Xamarin.Templates.Android.$(VsixVersion).nupkg">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <IncludeInVSIX>true</IncludeInVSIX>
        <VSIXSubPath>Templates</VSIXSubPath>
      </VsixSourceItem>
      <VsixSourceItem Include="Templates\Xamarin.Templates.IOS.$(VsixVersion).nupkg">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <IncludeInVSIX>true</IncludeInVSIX>
        <VSIXSubPath>Templates</VSIXSubPath>
      </VsixSourceItem>
      <VsixSourceItem Include="Templates\Xamarin.Templates.TVOS.$(VsixVersion).nupkg">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <IncludeInVSIX>true</IncludeInVSIX>
        <VSIXSubPath>Templates</VSIXSubPath>
      </VsixSourceItem>
      <VsixSourceItem Include="Templates\Xamarin.Templates.WATCHOS.$(VsixVersion).nupkg">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <IncludeInVSIX>true</IncludeInVSIX>
        <VSIXSubPath>Templates</VSIXSubPath>
      </VsixSourceItem>
    </ItemGroup>

    <Message Text="Added Content $(TemplatesFolder)\Xamarin.Templates.Multiplatform.$(VsixVersion).nupkg" Importance="high" />
    <Message Text="Added Content $(TemplatesFolder)\Xamarin.Templates.Android.$(VsixVersion).nupkg" Importance="high" />
    <Message Text="Added Content $(TemplatesFolder)\Xamarin.Templates.IOS.$(VsixVersion).nupkg" Importance="high" />
    <Message Text="Added Content $(TemplatesFolder)\Xamarin.Templates.TVOS.$(VsixVersion).nupkg" Importance="high" />
</Target>

  <Target Name="CopyArtifacts" AfterTargets="CreateVsixContainer" Condition="'$(Out)' != ''">
    <MakeDir Directories="$(Out)" Condition="!Exists('$(Out)')" />

    <Copy SourceFiles="@(_CreatedVsixContainer)" DestinationFolder="$(Out)" />
  </Target>

  <Target Name="IsExperimental" Returns="$(IsExperimental)" />
  <Target Name="IsSystemComponent" Returns="$(IsSystemComponent)" />

  <!-- Patch VSSDK uninstall VSIX broken logic
  Before we even import Clarius.VisualStudio targets, which in turn import VSSDK ones,
  we declare our own re-implementation of the UninstallExtension task that just marks
  an extension for deletion on the next VS restart. This completely removes the random
  build errors we were getting when a version flagged 0.1 couldn't uninstall a newer
  (i.e. 5.0) version that was already installed in the experimental hive.
   -->
  <UsingTask TaskName="UninstallExtension" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskAssembly)" Condition="'$(CodeTaskAssembly)' != ''">
    <ParameterGroup>
      <VsixIdentifier Required="true" />
      <RootSuffix  Required="true" />
      <FailIfNotInstalled  Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="Microsoft.CSharp" />
      <Using Namespace="Microsoft.Build.Framework" />
      <Using Namespace="System.Reflection" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
      Log.LogMessage("Marking extension for deletion on the next Visual Studio start: {0}.", VsixIdentifier);

      try {
          var tasks = AppDomain.CurrentDomain.GetAssemblies ().First (asm => asm.GetName ().Name == "Microsoft.VsSDK.Build.Tasks");
          var utilities = tasks.GetType ("Microsoft.VsSDK.Build.Tasks.ExtensionManagerUtilities", true);

          dynamic settingsManager = utilities.InvokeMember ("GetSettingsManagerForDevenv", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { RootSuffix }); ;
          var extensionManagerService = utilities.InvokeMember ("GetExtensionManagerService", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { settingsManager });
          var installedExtension = utilities.InvokeMember("GetInstalledExtension", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new[] { extensionManagerService, VsixIdentifier });
          var header = installedExtension.GetType ().GetProperty ("Header").GetValue (installedExtension);
          var installedVersion = header.GetType ().GetProperty ("Version").GetValue (header).ToString ();
          var installedPath = installedExtension.GetType ().GetProperty ("InstallPath").GetValue (installedExtension).ToString ();

          var scopeType = ((object)settingsManager).GetType ().GetMethod ("GetWritableSettingsStore").GetParameters ()[0].ParameterType;
          dynamic scope = Enum.Parse (scopeType, "UserSettings");

          dynamic settingsStore = settingsManager.GetWritableSettingsStore(scope);

          settingsStore.SetString(@"ExtensionManager\PendingDeletions", VsixIdentifier +  "," + installedVersion, installedPath);

          Log.LogMessage("Successfully marked extension for deletion on the next Visual Studio start: {0}, {1}.", VsixIdentifier, installedVersion);
      } catch (Exception ex) {
          // If uninstallation of the extension from the experimental instance didn't work, just warn, it's no big deal :)
          Log.LogWarningFromException(ex);
      }
]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
